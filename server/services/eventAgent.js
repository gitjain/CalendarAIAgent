const { OpenAI } = require('openai');
const mealPlanningClient = require('./mcpMealPlanningClient');

/**
 * @typedef {Object} AnalyzeEventOptions
 * @property {Object|null} tokens
 * @property {string|null} weatherSummary
 * @property {Array<{title:string,summary:string}>|null} googleDocsContext
 * @property {string[]|null} wishlistContext
 * @property {Object|null} mealPlanPreferences
 */

/**
 * @typedef {Object} AnalyzeEventResult
 * @property {string} text Raw LLM response text
 * @property {Object|null} mealPlanResult Successful meal-plan result (meals, nutrients, preferences)
 * @property {boolean} shouldAttemptMealPlan Whether this event met the meal-prep detection criteria
 * @property {Error|null} mealPlanError Error from tool or fallback generation
 * @property {string|null} mealPlanFallback Plain-text meal plan generated by the LLM in fallback mode
 */

class EventAgent {
  constructor() {
    if (!process.env.OPENAI_API_KEY) {
      throw new Error('OPENAI_API_KEY environment variable is required');
    }

    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
  }

  /**
   * @param {Object} event Calendar event metadata
   * @param {AnalyzeEventOptions} options
   * @returns {Promise<AnalyzeEventResult>}
   */
  async analyzeEvent(event, options = {}) {
    const {
      tokens = null,
      weatherSummary = null,
      googleDocsContext = null,
      wishlistContext = null,
      mealPlanPreferences = null,
      shouldAttemptMealPlan = this.#shouldGenerateMealPlan(event)
    } = options;

    const {
      mealPlanResult,
      mealPlanError,
      mealPlanFallback
    } = await this.#prepareMealPlanContext({
      event,
      tokens,
      mealPlanPreferences,
      shouldAttemptMealPlan
    });

    const systemPrompt = this.#buildSystemPrompt();
    const userPrompt = this.#buildUserPrompt({
      event,
      tokens,
      weatherSummary,
      googleDocsContext,
      wishlistContext,
      mealPlanResult,
      mealPlanError,
      mealPlanFallback,
      shouldAttemptMealPlan
    });

    const completion = await this.openai.chat.completions.create({
      model: 'gpt-4o-mini',
      temperature: 0.2,
      max_tokens: 1400,
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt }
      ]
    });

    const responseText = completion.choices[0].message.content;
    return {
      text: responseText,
      mealPlanResult,
      shouldAttemptMealPlan,
      mealPlanError,
      mealPlanFallback
    };
  }

  #buildSystemPrompt() {
    return `You are an expert event preparation assistant. Analyze calendar events and provide detailed, actionable preparation suggestions with specific checklists tailored to the event context.

Return your response as a JSON object with this exact structure:
{
  "eventSummary": "Brief description of the event and what preparation is needed",
  "preparationTasks": [
    {
      "id": "unique_task_id",
      "task": "Description of the task",
      "priority": "High|Medium|Low",
      "category": "Category name (e.g., Equipment, Transportation, Documentation, etc.)",
      "estimatedTime": "Time estimate (e.g., '15 minutes', '2 hours')",
      "suggestedDate": "ISO date string when this task should be completed",
      "description": "Detailed checklist of specific items to prepare (e.g., 'Pack instrument case, music sheets, metronome, spare strings, tuner, uniform, water bottle')"
    }
  ],
  "timeline": {
    "timeframe": ["task1", "task2"]
  },
  "tips": ["tip1", "tip2", "tip3", "tip4", "tip5"],
  "estimatedPrepTime": "Total preparation time estimate",
  "requiresMealPlanPreferences": false,
  "mealPlan": null
}

CONTEXT-SPECIFIC REQUIREMENTS:
- For MUSIC CLASSES: Include instrument, music sheets, accessories, uniform, transportation.
- For TRAVEL (local or global): MUST include transportation planning with Uber/ride booking option, packing lists, documents, accommodation details. For local trips, suggest Uber booking. For global trips, include airport transportation and Uber for local transit.
- For MEETINGS: Include agenda, materials, technology, location details, and transportation (Uber booking option if location requires travel).
- For CONCERTS/SHOWS: Include tickets, transportation (including Uber booking option), attire, timing.
- For WORK EVENTS: Include professional attire, materials, technology, preparation, and transportation (Uber booking option if needed).
- For CELEBRATIONS: Include gifts, attire, transportation (including Uber booking option), timing.

TRANSPORTATION REQUIREMENTS:
- For any event that requires travel (local or global), always include a task with category "Transportation" that mentions "Book Uber ride" or "Arrange transportation" in the checklist.
- Include specifics such as: "Book Uber from [origin] to [destination]", "Check Uber fare estimate", "Schedule Uber pickup time."

CORE REQUIREMENTS:
- Provide exactly 4-6 key preparation tasks.
- Each task must have a unique ID (task_1, task_2, etc.).
- Supply actionable, comma-separated checklist descriptions.
- Suggest realistic dates relative to the event.
- Provide exactly 4-5 practical tips tailored to the event context.

MEAL PLAN GUIDANCE:
- The server sets whether this event is meal prep. When "mealPlan.formattedText" is provided, summarize it briefly and reference it in at least one preparation task (e.g., review the plan, shop for ingredients, prep meals).
- If "requiresMealPlanPreferences" should be true (e.g., missing number of people, days, dietary restrictions, calorie targets), state this explicitly and list what is needed.
- If the external tool fails but fallback plan text is supplied, treat it the same way as formattedText‚Äîsummarize it and reference it in your tasks.
- If no meal plan data is provided, leave "mealPlan" null and "requiresMealPlanPreferences" false; do not invent meal-plan tasks.`;
  }

  #buildUserPrompt({
    event,
    tokens,
    weatherSummary,
    googleDocsContext,
    wishlistContext,
    mealPlanResult,
    mealPlanError,
    mealPlanFallback,
    shouldAttemptMealPlan,
    freeSlots
  }) {
    const lines = [];
    lines.push(`Analyze this calendar event:`);
    lines.push(`Title: ${event.title || 'Unknown event'}`);
    lines.push(`Type: ${event.type || 'general'}`);
    lines.push(`Date: ${event.date || 'unknown date'}`);
    lines.push(`End Date: ${event.endDate || 'unknown end date'}`);
    lines.push(`Location: ${event.location || 'N/A'}`);
    lines.push(`Description: ${event.description || 'No description provided.'}`);
    lines.push(`Source: ${event.source || 'unknown'}`);
    lines.push(`All Day: ${event.allDay ? 'Yes' : 'No'}`);

    if (event.attendees?.length) {
      lines.push(`Attendees: ${event.attendees.join(', ')}`);
    }

    if (event.extendedProperties?.private) {
      lines.push(`Extended Properties: ${JSON.stringify(event.extendedProperties.private)}`);
    }

    if (event.relatedDocuments?.length) {
      lines.push(`Related Documents: ${event.relatedDocuments.join(', ')}`);
    }

    if (weatherSummary) {
      lines.push('\nWeather Summary:');
      lines.push(weatherSummary);
    }

    if (wishlistContext?.length) {
      lines.push('\nWishlist Context:');
      wishlistContext.forEach(entry => {
        lines.push(`- ${entry}`);
      });
    }

    // Add free slots if available
    if (freeSlots && freeSlots.length > 0) {
      lines.push('\nAvailable Free Time Slots (between now and event):');
      freeSlots.slice(0, 10).forEach((slot, idx) => {
        const startTime = new Date(slot.startTime);
        const endTime = new Date(slot.endTime);
        const dateStr = startTime.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
        const timeStr = startTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
        const duration = Math.round(slot.duration / 60); // Convert to hours
        lines.push(`  ${idx + 1}. ${dateStr} at ${timeStr} (${duration}h available)`);
      });
      lines.push('\nWhen suggesting task times, prefer these free slots to avoid calendar conflicts.');
    }

    if (tokens?.access_token) {
      lines.push('\nUser has Google Calendar access.');
    }

    if (mealPlanResult && mealPlanResult.formattedText) {
      lines.push('\nMeal Plan Details:');
      lines.push(mealPlanResult.formattedText);
      if (mealPlanResult.preferences) {
        lines.push(`Preferences Provided: Days ${mealPlanResult.preferences.days}, Family Size ${mealPlanResult.preferences.familySize || 'N/A'}, Diet ${mealPlanResult.preferences.diet || 'none'}, Exclusions ${mealPlanResult.preferences.exclude || 'none'}.`);
      }
      lines.push('Summarize this plan and reference it in at least one preparation task (review, shop ingredients, prep meals).');
    } else if (mealPlanFallback) {
      lines.push('\nMeal Plan Fallback:');
      lines.push(mealPlanFallback);
      lines.push('Summarize this fallback text and include a preparation task that references it.');
    } else if (shouldAttemptMealPlan && mealPlanError) {
      lines.push('\nMeal Plan Status:');
      lines.push(`- Meal plan could not be generated: ${mealPlanError.message}`);
      lines.push('- Let the user know that they need to connect Google or try again.');
    } else if (shouldAttemptMealPlan) {
      lines.push('\nMeal Plan Status:');
      lines.push('- Meal plan text is not available yet. Ask the user for preferences such as number of people, number of days, dietary restrictions, and calorie targets.');
    }

    lines.push('\nReturn only the JSON object specified in the system instructions.');

    return lines.join('\n');
  }

  #shouldGenerateMealPlan(event) {
    const text = `${event.title || ''} ${event.description || ''} ${event.type || ''}`.toLowerCase();
    const hasPrep = text.includes('prep');
    console.log(`[meal-plan-detection] Event: "${event.title}"`);
    console.log(`[meal-plan-detection] Text to check: "${text}"`);
    console.log(`[meal-plan-detection] Has "prep": ${hasPrep}`);
    
    if (!hasPrep) {
      console.log(`[meal-plan-detection] ‚ùå No "prep" keyword found - skipping meal plan`);
      return false;
    }
    
    const mealKeywords = ['meal', 'lunch', 'dinner', 'breakfast', 'snack'];
    const hasMealKeyword = mealKeywords.some(keyword => text.includes(keyword));
    console.log(`[meal-plan-detection] Has meal keyword: ${hasMealKeyword}`);
    
    if (hasMealKeyword) {
      console.log(`[meal-plan-detection] ‚úÖ Meal prep event detected - will attempt meal plan generation`);
    } else {
      console.log(`[meal-plan-detection] ‚ùå No meal keywords found - skipping meal plan`);
    }
    
    return hasMealKeyword;
  }

  async #prepareMealPlanContext({ event, tokens, mealPlanPreferences, shouldAttemptMealPlan }) {
    console.log('[meal-plan-context] Starting meal plan preparation:', {
      shouldAttemptMealPlan,
      eventTitle: event?.title
    });

    if (!shouldAttemptMealPlan) {
      console.log('[meal-plan-context] ‚ùå Skipping - shouldAttemptMealPlan is false');
      return { mealPlanResult: null, mealPlanError: null, mealPlanFallback: null };
    }

    console.log('[meal-plan-context] ‚úÖ Attempting to generate meal plan...');
    try {
      const mealPlanResult = await mealPlanningClient.generateMealPlanForEvent(
        event,
        tokens,
        mealPlanPreferences || {}
      );
      console.log('[meal-plan-context] ‚úÖ Meal plan generated successfully');
      return { mealPlanResult, mealPlanError: null, mealPlanFallback: null };
    } catch (error) {
      console.error('[meal-plan-context] ‚ùå Meal plan generation failed:', error.message);
      console.log('[meal-plan-context] Attempting LLM fallback generation with user preferences...');
      const fallback = await this.#generateMealPlanFallback(event, mealPlanPreferences);
      if (fallback) {
        console.log('[meal-plan-context] ‚úÖ LLM fallback meal plan generated');
        return { mealPlanResult: null, mealPlanError: null, mealPlanFallback: fallback };
      }
      console.log('[meal-plan-context] ‚ùå LLM fallback also failed');
      return { mealPlanResult: null, mealPlanError: error, mealPlanFallback: null };
    }
  }

  async #generateMealPlanFallback(event, preferences = {}) {
    try {
      // Apply default values for preferences
      const days = preferences.days !== undefined ? preferences.days : 7;
      const people = preferences.people || preferences.familySize || 2; // Default to 2 people
      const targetCalories = preferences.targetCalories !== undefined ? preferences.targetCalories : 2000;
      const diet = preferences.diet || 'balanced';
      const exclude = preferences.exclude || 'none';
      
      console.log('[meal-plan-fallback] Using preferences (with defaults):', { days, people, targetCalories, diet, exclude });

      const fallbackPrompt = `Generate a ${days}-day meal plan for ${people} people.

Requirements:
- Diet: ${diet === 'balanced' ? 'balanced/no restrictions' : diet}
- Target calories: ${targetCalories} per day per person
- Exclude: ${exclude}

For each day (monday through ${days === 7 ? 'sunday' : 'day' + days}), provide 3 meals (breakfast, lunch, dinner).
Each meal should have: title, prep time (minutes), key ingredients (3-5 items), and brief instructions (1-2 sentences).

Return ONLY valid JSON in this exact format (no markdown, no code blocks):
{"week":{"monday":{"meals":[{"title":"Oatmeal with Berries","readyInMinutes":15,"ingredients":["oats","berries","honey"],"instructions":"Cook oats, top with berries."}]}}}

Keep it simple and ensure the JSON is valid. Focus on practical, easy recipes.`;

      const completion = await this.openai.chat.completions.create({
        model: 'gpt-4o-mini',
        temperature: 0.3,
        max_tokens: 4000,
        response_format: { type: "json_object" },
        messages: [
          { role: 'system', content: 'You are a meal planning expert. Return only valid JSON without any markdown formatting or code blocks. Keep responses concise.' },
          { role: 'user', content: fallbackPrompt }
        ]
      });

      let responseText = completion.choices[0].message.content.trim();
      
      // Remove markdown code blocks if present
      responseText = responseText.replace(/```json\s*/g, '').replace(/```\s*/g, '');
      
      // Try to parse the JSON response
      try {
        const mealPlanData = JSON.parse(responseText);
        // Format it as a text summary for the existing flow
        const formattedText = this.#formatMealPlanAsText(mealPlanData, days, people);
        console.log('[meal-plan-fallback] Successfully formatted meal plan');
        return formattedText;
      } catch (parseError) {
        console.error('[meal-plan-fallback] Failed to parse LLM JSON response:', parseError.message);
        console.error('[meal-plan-fallback] Response length:', responseText.length);
        console.error('[meal-plan-fallback] Response preview:', responseText.substring(0, 300));
        
        // Try to create a simple text-based meal plan as last resort
        const simplePlan = this.#createSimpleMealPlan(days, people, diet, targetCalories, exclude);
        console.log('[meal-plan-fallback] Using simple fallback meal plan');
        return simplePlan;
      }
    } catch (fallbackError) {
      console.error('[meal-plan-fallback] LLM fallback generation failed:', fallbackError.message);
      return null;
    }
  }

  #createSimpleMealPlan(days, people, diet, targetCalories, exclude) {
    const dietLabel = diet === 'balanced' ? 'Balanced' : diet.charAt(0).toUpperCase() + diet.slice(1);
    let text = `üìÖ ${days}-Day ${dietLabel} Meal Plan for ${people} ${people === 1 ? 'person' : 'people'}\n\n`;
    text += `üéØ Target: ${targetCalories} calories per day per person\n`;
    if (exclude && exclude !== 'none') {
      text += `üö´ Excluding: ${exclude}\n`;
    }
    text += `\n`;
    
    const dayNames = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
    const meals = {
      breakfast: ['Oatmeal with Berries', 'Scrambled Eggs & Toast', 'Greek Yogurt Parfait', 'Avocado Toast', 'Smoothie Bowl', 'Pancakes', 'Breakfast Burrito'],
      lunch: ['Grilled Chicken Salad', 'Veggie Wrap', 'Quinoa Bowl', 'Soup & Sandwich', 'Pasta Primavera', 'Buddha Bowl', 'Taco Salad'],
      dinner: ['Baked Salmon & Veggies', 'Stir-Fry with Rice', 'Grilled Chicken & Potatoes', 'Vegetable Curry', 'Spaghetti & Meatballs', 'Roasted Vegetables & Protein', 'Fajitas']
    };
    
    for (let i = 0; i < days && i < 7; i++) {
      text += `‚îÅ‚îÅ‚îÅ Day ${i + 1}: ${dayNames[i]} ‚îÅ‚îÅ‚îÅ\n\n`;
      text += `üçΩÔ∏è  BREAKFAST: ${meals.breakfast[i]}\n`;
      text += `   ‚è±Ô∏è  Prep Time: 15-20 minutes\n\n`;
      text += `üçΩÔ∏è  LUNCH: ${meals.lunch[i]}\n`;
      text += `   ‚è±Ô∏è  Prep Time: 20-30 minutes\n\n`;
      text += `üçΩÔ∏è  DINNER: ${meals.dinner[i]}\n`;
      text += `   ‚è±Ô∏è  Prep Time: 30-40 minutes\n\n`;
    }
    
    text += '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n';
    text += '‚ú® Simple Meal Plan (AI Generation Fallback)\n';
    text += 'üí° Tip: Adjust portions and ingredients based on your preferences';
    
    return text;
  }

  #formatMealPlanAsText(mealPlanData, days, people) {
    let text = `üìÖ ${days}-Day Meal Plan for ${people} ${people === 1 ? 'person' : 'people'}\n\n`;
    
    if (mealPlanData.week) {
      const dayNames = Object.keys(mealPlanData.week);
      dayNames.forEach((day, index) => {
        const dayData = mealPlanData.week[day];
        text += `‚îÅ‚îÅ‚îÅ Day ${index + 1}: ${day.charAt(0).toUpperCase() + day.slice(1)} ‚îÅ‚îÅ‚îÅ\n\n`;
        
        if (dayData.meals && Array.isArray(dayData.meals)) {
          dayData.meals.forEach(meal => {
            const mealType = meal.type || 'Meal';
            text += `üçΩÔ∏è  ${mealType.toUpperCase()}: ${meal.title}\n`;
            text += `   ‚è±Ô∏è  Prep Time: ${meal.readyInMinutes || 'N/A'} minutes\n`;
            
            if (meal.nutrition) {
              text += `   üìä Nutrition: ${meal.nutrition.calories || 'N/A'} cal`;
              if (meal.nutrition.protein) text += ` | Protein: ${meal.nutrition.protein}`;
              if (meal.nutrition.carbs) text += ` | Carbs: ${meal.nutrition.carbs}`;
              if (meal.nutrition.fat) text += ` | Fat: ${meal.nutrition.fat}`;
              text += '\n';
            }
            
            if (meal.ingredients && meal.ingredients.length > 0) {
              text += `   üõí Key Ingredients: ${meal.ingredients.slice(0, 5).join(', ')}`;
              if (meal.ingredients.length > 5) text += ` + ${meal.ingredients.length - 5} more`;
              text += '\n';
            }
            
            if (meal.instructions) {
              const shortInstructions = meal.instructions.substring(0, 100);
              text += `   üìù ${shortInstructions}${meal.instructions.length > 100 ? '...' : ''}\n`;
            }
            
            text += '\n';
          });
        }
        text += '\n';
      });
    }
    
    text += '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n';
    text += '‚ú® AI-Generated Meal Plan\n';
    text += 'üí° Tip: Adjust portions based on your needs';
    return text;
  }
}

module.exports = EventAgent;
