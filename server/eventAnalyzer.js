const weatherService = require('./services/weatherService');
const documentProcessor = require('./services/documentProcessor');
const EventAgent = require('./services/eventAgent');
const { findFreeSlots } = require('./services/calendarUtils');
const { google } = require('googleapis');

class CalendarEventAnalyzer {
  constructor() {
    this.agent = new EventAgent();
  }

  async analyzeEvent(event, tokens = null, options = {}) {
    const { weatherData, weatherSuggestions } = await this.#fetchWeatherContext(event);
    const documentContext = await this.#fetchDocumentContext(event, tokens);
    const freeSlots = await this.#fetchCalendarSlots(event, tokens, options);
    const { 
      shouldAttemptMealPlan: shouldAttemptMealPlanPref = false,
      mealPlanPreferences = null
    } = options;

    try {
      const {
        text: responseText,
        mealPlanResult,
        shouldAttemptMealPlan,
        mealPlanError,
        mealPlanFallback
      } = await this.agent.analyzeEvent(event, {
        tokens,
        weatherSummary: weatherData ? buildWeatherSummary(weatherData, weatherSuggestions) : null,
        googleDocsContext: documentContext?.documents?.map(doc => ({
          title: doc.title,
          summary: doc.wasSummarized ? doc.text : doc.summary || doc.text
        })),
        wishlistContext: null,
        shouldAttemptMealPlan: shouldAttemptMealPlanPref,
        mealPlanPreferences: mealPlanPreferences,
        freeSlots: freeSlots
      });

      const analysis = this.parseOpenAIResponse(responseText);

      // Add weather data to the response if available
      if (weatherData) {
        analysis.weather = {
          temperature: weatherData.temperature,
          feelsLike: weatherData.feelsLike,
          description: weatherData.description,
          main: weatherData.main,
          precipitation: Math.round(weatherData.precipitation),
          windSpeed: weatherData.windSpeed,
          humidity: weatherData.humidity,
          location: weatherData.location,
          suggestions: weatherSuggestions,
          fetchedAt: new Date().toISOString(),
          queryLocation: event.location
        };
      }

      if (mealPlanResult && mealPlanResult.mealPlan) {
        console.log('[eventAnalyzer] Using Spoonacular meal plan');
        analysis.mealPlan = {
          meals: mealPlanResult.mealPlan.meals || [],
          message: 'A personalized meal plan has been generated. Review the suggested menu below.',
          preferences: mealPlanResult.preferences || null,
          nutrients: mealPlanResult.mealPlan.nutrients || null,
          formattedText: mealPlanResult.formattedText || null,
          source: 'spoonacular'
        };

        analysis.requiresMealPlanPreferences = false;

        if (analysis.preparationTasks && Array.isArray(analysis.preparationTasks)) {
          const existingTask = analysis.preparationTasks.find(task => task.isMealPlanTask);
          if (!existingTask) {
            analysis.preparationTasks.unshift({
              id: 'meal_plan_review',
              task: 'Review Generated Meal Plan',
              priority: 'High',
              category: 'Meal Planning',
              estimatedTime: '10 minutes',
              suggestedDate: event.date,
              description: `Review the ${mealPlanResult.preferences?.days || 7}-day meal plan with ${mealPlanResult.mealPlan.meals?.length || 0} recipes`,
              isMealPlanTask: true
            });
          }
        }
      } else if (mealPlanFallback) {
        // LLM fallback succeeded - show it
        console.log('[eventAnalyzer] Using LLM-generated meal plan (Spoonacular fallback)');
        analysis.mealPlan = {
          fallback: mealPlanFallback,
          message: 'Meal plan generated by AI (Spoonacular API unavailable).',
          source: 'llm'
        };
        analysis.requiresMealPlanPreferences = false;
      } else if (shouldAttemptMealPlan && !mealPlanResult && !mealPlanFallback) {
        // Meal plan was attempted but both Spoonacular and LLM fallback failed
        // OR this is the first analysis and we need user preferences
        console.log('[eventAnalyzer] Meal plan generation failed or not attempted - requesting user preferences');
        analysis.requiresMealPlanPreferences = true;
        analysis.mealPlan = {
          message: 'Please provide your meal planning preferences to generate a personalized meal plan.',
          source: null
        };
      }
      // If both tool and fallback failed, don't set analysis.mealPlan
      // This prevents showing an empty meal plan section in the UI

      return analysis;
    } catch (error) {
      console.error('OpenAI API Error:', error);
      throw new Error(`Failed to analyze event with AI: ${error.message}`);
    }
  }

  async #fetchWeatherContext(event) {
    if (!event.location || !event.date) {
      return { weatherData: null, weatherSuggestions: [] };
    }

    try {
      const weatherData = await weatherService.getWeatherForEvent(event.location, event.date);
      if (!weatherData) {
        return { weatherData: null, weatherSuggestions: [] };
      }

      const weatherSuggestions = weatherService.generateWeatherSuggestions(
        weatherData,
        event.type,
        event.title
      );

      console.log(`ðŸŒ¤ï¸  Weather data fetched for ${event.location}: ${weatherData.description}`);

      return { weatherData, weatherSuggestions };
    } catch (error) {
      console.warn('Could not fetch weather data:', error.message);
      return { weatherData: null, weatherSuggestions: [] };
    }
  }

  async #fetchDocumentContext(event, tokens) {
    if (!event.description || !tokens) {
      return null;
    }

    try {
      const docResult = await documentProcessor.processDocuments(event.description, tokens);
      if (docResult && docResult.hasDocuments) {
        console.log(`ðŸ“„ Processed ${docResult.documents.length} document(s) for event analysis`);
        return docResult;
      }
    } catch (error) {
      console.warn('Could not process documents:', error.message);
    }

    return null;
  }

  parseOpenAIResponse(content) {
    try {
      // Try to parse the JSON response
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0]);
        
        // Ensure all suggested dates/times are in the future
        if (parsed.preparationTasks && Array.isArray(parsed.preparationTasks)) {
          parsed.preparationTasks = parsed.preparationTasks.map(task => {
            if (task.suggestedDate) {
              task.suggestedDate = this.ensureFutureDate(task.suggestedDate);
            }
            return task;
          });
        }
        
        return parsed;
      }
      
      // If no JSON found, throw error
      throw new Error('Invalid JSON response from OpenAI');
    } catch (error) {
      console.error('Error parsing OpenAI response:', error);
      // Return a fallback response structure
      return {
        eventSummary: "Analysis could not be completed due to response format error.",
        preparationTasks: [
          {
            task: "Review event details manually",
            priority: "Medium",
            category: "Planning",
            estimatedTime: "10 minutes"
          }
        ],
        timeline: {
          "1 day before": ["Review event details"]
        },
        tips: ["Double-check event time and location"],
        estimatedPrepTime: "30 minutes"
      };
    }
  }

  /**
   * Ensure the suggested date is in the future
   * If the date is in the past, adjust it to be at least 1 hour from now
   * @param {string} suggestedDate - ISO date string
   * @returns {string} ISO date string in the future
   */
  ensureFutureDate(suggestedDate) {
    try {
      const now = new Date();
      const suggested = new Date(suggestedDate);
      
      // If suggested date is in the past or less than 1 hour from now, adjust it
      const oneHourFromNow = new Date(now.getTime() + 60 * 60 * 1000); // 1 hour from now
      
      if (suggested <= oneHourFromNow) {
        // Set to 1 hour from now
        return oneHourFromNow.toISOString();
      }
      
      return suggested.toISOString();
    } catch (error) {
      console.error('Error ensuring future date:', error);
      // If parsing fails, return 1 hour from now
      const oneHourFromNow = new Date(Date.now() + 60 * 60 * 1000);
      return oneHourFromNow.toISOString();
    }
  }

  /**
   * Fetch calendar free slots for calendar-aware scheduling
   * @param {Object} event - The event being analyzed
   * @param {Object} tokens - Google OAuth tokens
   * @param {Object} options - Options including checkAvailability flag
   * @returns {Array|null} Array of free slots or null if unavailable
   */
  async #fetchCalendarSlots(event, tokens, options = {}) {
    // Check if calendar checking is enabled (default: true)
    if (options.checkAvailability === false) {
      return null;
    }

    // Require tokens for calendar access
    if (!tokens?.access_token) {
      console.log('â„¹ï¸  [Calendar Slots] No tokens available, skipping calendar check');
      return null;
    }

    // Require event date
    if (!event.date) {
      console.log('â„¹ï¸  [Calendar Slots] No event date, skipping calendar check');
      return null;
    }

    try {
      const oauth2Client = new google.auth.OAuth2();
      oauth2Client.setCredentials(tokens);
      const calendar = google.calendar({ version: 'v3', auth: oauth2Client });
      
      const now = new Date();
      const eventDate = new Date(event.date);
      
      // Only check if event is in the future
      if (eventDate <= now) {
        console.log('â„¹ï¸  [Calendar Slots] Event is in the past, skipping calendar check');
        return null;
      }
      
      console.log(`ðŸ“… [Calendar Slots] Fetching events between now and ${eventDate.toISOString()}`);
      
      // Fetch events between now and event date
      const response = await calendar.events.list({
        calendarId: 'primary',
        timeMin: now.toISOString(),
        timeMax: eventDate.toISOString(),
        singleEvents: true,
        orderBy: 'startTime',
        maxResults: 250
      });
      
      // Normalize calendar events
      const calendarEvents = response.data.items.map(e => ({
        date: e.start?.dateTime || e.start?.date,
        endDate: e.end?.dateTime || e.end?.date,
        title: e.summary || 'Untitled'
      })).filter(e => e.date); // Filter out events without dates
      
      // Find free slots
      const freeSlots = findFreeSlots(calendarEvents, now, eventDate, {
        minDuration: 60 // 1 hour minimum for preparation tasks
      });
      
      console.log(`âœ… [Calendar Slots] Found ${freeSlots.length} free slots between now and event`);
      
      return freeSlots.length > 0 ? freeSlots : null;
    } catch (error) {
      console.warn('âš ï¸  [Calendar Slots] Could not check calendar availability:', error.message);
      // Gracefully continue without slots - never fail the analysis
      return null;
    }
  }

}

function buildWeatherSummary(weatherData, suggestions) {
  const lines = [];
  lines.push('Weather Forecast:');
  lines.push(`- Location: ${weatherData.location}`);
  lines.push(`- Temperature: ${weatherData.temperature}Â°C (Feels like ${weatherData.feelsLike}Â°C)`);
  lines.push(`- Conditions: ${weatherData.description}`);
  lines.push(`- Precipitation: ${Math.round(weatherData.precipitation)}% chance`);
  lines.push(`- Wind: ${weatherData.windSpeed} km/h`);
  lines.push(`- Humidity: ${weatherData.humidity}%`);
  if (suggestions?.length) {
    lines.push('Weather-based suggestions:');
    suggestions.forEach(s => lines.push(`- ${s}`));
  }
  return lines.join('\n');
}

module.exports = CalendarEventAnalyzer;
